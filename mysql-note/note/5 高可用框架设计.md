# 高可用框架设计

## 1 mysql复制

mysql 复制功能分担读负载（无法分担写负载）

复制功能基于二进制日志增量复制（异步  有延迟）

复制解决的问题：
实现数据读的负载均衡
不同服务器上的数据分布
利用DNS 轮询的方式把程序的读连接到不同的备份数据库中
实现数据库的在线升级

## 3 mysql二进制日志

mysql 服务层日志
二进制日志
慢查询日志
通用日志 

mysql 存储引擎层日志：
innodb的 重做日志
innodb的 回滚日志

二进制日志：
记录了所有对mysql数据库的修改事件 包括CRUD 和表机构修改（都是执行成功的）（回滚，语法错误等日志不会存储）

可通过binlog对二进制日志进行查看

### 3.1 基于段的格式二进制日志格式 （）

基于段的格式  binlog_format = STATEMENT 
优点：
    日志记录量相对较小，节约磁盘级网络IO
    只对一条记录修改或插入
    row格式所产生的日志量小于段产生的日志量
缺点：
    必须记录上下文信息保证语句在从服务器上执行结构和在主服务器上相同
    对UUID() user() 等非确定性函数还是无法复制，可能造成mysql复制的主备服务器的不一致

mysql>show variables like 'binlog_format'  查看日志格式
mysql>set session binlog_format like 'binlog_format'  修改日志格式为基于段的日志格式


### 3.2 基于行的二进制日志格式 （mysql5.7 级以后默认的日志格式）

基于行的格式  binlog_format = ROW

ROW格式可以避免mysql复制中的主从不一致问题
优点：
    使mysql主从复制更加安全
    对每一行数据的修改比基于段的复制更高效    
    误操作时，反向处理方式来达到数据恢复的目的
缺点：
    记录日志量较大
    **binlog_row_image 在5.7版本中可以设置（FULL 全纪录，MINIMAL只记录更新列的字段，只有指定列更新时才做记录   ）**
    binlog_row_image=[FULL][MINIMAL][NOBLOB]
    
       
ROW 与 STATEMENT的不同：
    
    同一条sql语句修改1000条数据 ，STATEMENT只会记录这条sql语句，ROW会有1000条记录分别记录每一行的数据修改
    
### 3.3 混合日志格式 （mysql5.7 级以后默认的日志格式）

混合日志格式 binlog_format = MIXED
特点：
    根据sql语句由系统决定基于段和基于行的日志格式中进行选择
    数据量的大小由所执行的sql语句决定
    
### 3.4 日志格式选择

 建议：   【1】  binlog_format = MIXED 或者 binlog_format = ROW
          【2】  使用 binlog_format = ROW 时 建议binlog_row_image=minimal
 

## 4 mysql二进制日志对复制的影响

### 4.1 基于SQL语句的复制（SBR） （逻辑复制）
优点：
    生成的日志量少
    并不强调要求中从数据库的表定义完全相同
    比行复制灵活
缺点：
    非确定事件，无法保证中从复制数据的一致性
    对于存储过程、触发器，自定义函数进行的修改也可能造成数据不一致
     比行复制在执行上需要更多的锁
### 4.2 基于行的复制（RBR）（未执行sql）
优点：
缺点：
    要求只从数据库的表机构相同，可能会中断复制   
    无法在从上单独执行触发器
### 4.3 混合模式

## 5 mysql复制工作方式

必须开启二进制日志（尽量在数据库配置的时候就开启二进制日志）

工作方式：
    【1】主服务将变更写入二进制日志
    【2】从服务器 读取 主 的二进制日志变更并写入到relay_log中
        **分为基于日志点的复制和基于GTID的复制**
    【3】 在从服务器上重放 relay_log 中的日志
          基于sql段的日志是从库上重新执行记录的SQL
          基于行的日志是从库上直接应用对数据库行的修改















































