# mysql 学习

# 1 简介

**不要再主数据库上进行数据备份 大型活动前取消这类操作**

## 1.1 影响数据库性能的因素
    sql查询速度
    服务器硬件
    网卡流量
    磁盘IO
## 1.2 
QPS  每秒处理的查询量 （例如：每秒处理100sql 那么 QPS就<=100）（对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力）
TPS   即服务器每秒处理的事务数 （TPS包括一条消息入和一条消息出，加上一次用户数据库访问）

**大多数数据库性能问题都是慢查询导致的**

## 1.3
大量的并发：数据库连接数被占满 （mysql  max_connection 默认为 100）
超高的cpu使用率： 因cpu资源被耗尽而出现宕机
磁盘IO性能突然下降（解决办法  使用更快的磁盘设备）
网卡流量（如何避免无法连接数据库的情况）：
    减少从服务器的数量 （从服务器要从主服务器上复制日志）
    进行分级缓存
    避免使用 select * 进行查询
## 1.4 大表带来的问题
 
什么样的表称之为大表（大概定义）

    记录数行数巨大 ，单表超过千万行
    表数据文件巨大，表数据文件超过10G
       
大表对查询的影响
    慢查询：很难再一定的时间内过滤出需要的数据
大表对DDL操作的影响
    建立索引需要很长时间
        风险：
        mysql版本<5.5 建立索引会锁表
        mysql版本>=5.5 建立索引不会锁表 但会引起主从延迟   
    修改表机构需要长时间锁表   
        风险：
        会造成长时间的主从延迟
        影响正常的数据库操作
    
 如何处理数据库中的大表：
 分库分表一张大表分成多个小表 
     难点：
        分表主键的选择
        分表后跨分区数据的查询和统计  
 大表的历史数据归档
      难点：
         归档时间点的选择
         如何进行归档操作 
         
## 1.5 大事务的问题

【1】sql标准中定义的四种隔离级别（隔离级别由低到高）（并发性由高到低）
    未提交读  READ UNCOMMITED （脏读）   不推荐 
    已提交读  READ COMMITED （不可重复读） （一般数据库的默认隔离级别 sqlserver PostgreSQL  oracle ）
    可重复读  REPEATABLE READ （同一个事务中查询结果不会受另外一个事务结果的影响   mysql的默认隔离级别）
    可串行化  SERIALIZABLE   （在读取的每一行都加锁）
    
    
    例如： 一个查询事务  一个添加事务  同时操作时
    
    可重复读： 查询事务不会读取到添加事务添加的值
    已提交读： 查询事务会读取到添加事务添加的值
    例如：（数据库中 原本为 1 2 3 三个数值 ，添加事务添加一个 4 ，事务查询查询小于5的数）   
    可重复读结果：1 2 3
    已提交读结果： 1 2 3 4 
【2】大事务的定义：运行时间比较长  ，操作的数据比较多的事务
        风险：
            锁定太多的数据，造成大量的阻塞和锁超时
            回滚时所需要时间比较长
            执行时间长，容易造成主从延迟    
【3】如何处理大事务
     避免一次处理太多的数据
     移出不必要在事务中的select操作      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
            