# mysql 的锁


## 1 参考资料

https://juejin.im/post/5b55b842f265da0f9e589e79  数据库两大神器【索引和锁】

## 2 简介

mysql所类型：排它锁，共享锁，表锁，页锁，间隙锁，意向排它锁，意向共享锁，行锁，读锁，写锁，乐观锁，悲观锁，死锁。
这些名词有的博客又直接写锁的英文的简写--->X锁，S锁，IS锁，IX锁，MMVC...


对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)

MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，
这个过程并不需要用户干预

## 3 锁的分类

【1】从锁的粒度，我们可以分成两大类：
        
    表锁 :开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
    行锁： 销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高
    【1】
    不同的存储引擎支持的锁粒度是不一样的：
    InnoDB行锁和表锁都支持！
    MyISAM只支持表锁！
    【2】
    InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁
    也就是说，InnoDB的行锁是基于索引的！

【2】表锁下又分为两种模式

表读锁（Table Read Lock）
表写锁（Table Write Lock）

**在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！**
**读锁和写锁是互斥的，读写操作是串行。**
**如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里边，写锁是优先于读锁的！**
**写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates**

MyISAM可以支持查询和插入操作的并发进行。可以通过系统变量concurrent_insert来指定哪种模式，在MyISAM中它默认是：如果MyISAM表中没有空洞（即表的中间没有被删除的行），
MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。

【3】行锁细讲

Innodb中 表锁对我们程序员来说几乎是透明的，即使InnoDB不走索引，加的表锁也是自动的
InnoDB实现了以下两种类型的行锁：

    共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
    也叫做读锁：读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改。
    
    排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
    也叫做写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。

为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：
    
    意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
    意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
    意向锁也是数据库隐式帮我们做了，不需要程序员操心！


## 4 MVCC和事务的隔离级别

数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别
MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：MVCC就是行级锁的一个变种(升级版)。

事务的隔离级别就是通过锁的机制来实现，只不过隐藏了加锁细节
















































